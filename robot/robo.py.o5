#!/usr/bin/python3

import time
from Adafruit_MotorHAT import Adafruit_MotorHAT, Adafruit_DCMotor
import Adafruit_GPIO.I2C as I2C
from smbus2 import SMBus  # I2C 버스를 열고 닫기 위한 smbus2 사용
import fcntl  # 파일 잠금을 위한 fcntl 모듈

import Jetson.GPIO as GPIO
import signal

import cv2
import asyncio
import websockets
import base64
import os
import json

from gsstr import gstreamer_pipeline

# 잠금을 위한 파일 생성
LOCK_FILE = "/tmp/i2c_bus_lock"

# 파일 잠금 (I2C 버스 접근을 동기화하기 위한 방법)
def acquire_lock(lockfile):
    lockfile_handle = open(lockfile, "w")
    fcntl.flock(lockfile_handle, fcntl.LOCK_EX)  # 배타적 잠금
    return lockfile_handle

# 파일 잠금 해제
def release_lock(lockfile_handle):
    fcntl.flock(lockfile_handle, fcntl.LOCK_UN)
    lockfile_handle.close()


# I2C 버스 열기 (smbus2 사용)
def open_i2c_bus():
    return SMBus(1)  # I2C 버스 1 (/dev/i2c-1)을 엽니다.

# I2C 버스 닫기
def close_i2c_bus(i2c_bus):
    i2c_bus.close()


class robot_control:

    angle = 0
    speed = 0

    def __init__(self):

        signal.signal(signal.SIGINT, self.sig_callback)
        signal.signal(signal.SIGTERM, self.sig_callback)

        # Jetson Nano에서는 I2C 버스를 직접 지정
        I2C.get_default_bus = lambda: 1  # i2c-1 버스를 사용

        # Motor HAT 객체 생성
        self.mh = Adafruit_MotorHAT(addr=0x60)

        # 모터 초기화
        self.leftMotor = self.mh.getMotor(1)  # 좌측 모터
        self.rightMotor = self.mh.getMotor(2)  # 우측 모터

        # 카메라를 초기화 (초기화 시점에 카메라를 열도록 수정)
        self.cap = cv2.VideoCapture(gstreamer_pipeline(), cv2.CAP_GSTREAMER)
        if not self.cap.isOpened():
            print("카메라를 열 수 없습니다.")
            return
        else:
            print("카메라가 정상적으로 열렸습니다.")

        # 포트별 클라이언트 상태 변수 초기화
        self.video_client_connected = False
        self.command_client_connected = False

        # 프레임 캡처 루프는 이벤트 루프가 실행 중인 상태에서 시작됩니다.

        # 프레임 공유를 위한 변수 초기화
        self.frame_lock = asyncio.Lock()
        self.current_frame = None

    def stop(self):
        self.mh.getMotor(1).run(Adafruit_MotorHAT.RELEASE)
        self.mh.getMotor(2).run(Adafruit_MotorHAT.RELEASE)

    # 모터 속도 및 방향 제어 함수
    def move(self, angle, speed):

        # 각도를 -45 ~ 45 사이로 제한
        # speed -255 ~ 255 사이로 제한
        angle = max(-45, min(45, angle))
        speed = max(-255, min(255, speed))

        # 기존 값과 ±5 차이가 나지 않으면 함수 종료
        angle_diff_alpha = 5
        if abs(angle - self.angle) <= angle_diff_alpha and speed == self.speed:
            return

        self.angle = angle
        self.speed = speed

        i2c_bus = open_i2c_bus()

        # stop
        if angle == 0 and speed == 0:
            self.mh.getMotor(1).run(Adafruit_MotorHAT.RELEASE)
            self.mh.getMotor(2).run(Adafruit_MotorHAT.RELEASE)

        # go
        elif angle == 0 and speed > 0:
            print("start here")
            self.leftMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.leftMotor.setSpeed(abs(int(speed)))

            self.rightMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.rightMotor.setSpeed(abs(int(speed)))

        # back
        elif angle == 0 and speed < 0:
            self.leftMotor.run(Adafruit_MotorHAT.FORWARD)
            self.rightMotor.run(Adafruit_MotorHAT.FORWARD)
            self.leftMotor.setSpeed(abs(int(speed)))
            self.rightMotor.setSpeed(abs(int(speed)))

        # left(+)
        elif angle > 0 and speed > 0:  # left direction turn
            self.leftMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.rightMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.leftMotor.setSpeed(abs(int(speed)))
            self.rightMotor.setSpeed(abs(int(speed + abs(angle))))  # right motor value up

        # right(-)
        elif angle < 0 and speed > 0:  # right direction turn
            print("right")
            self.leftMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.rightMotor.run(Adafruit_MotorHAT.BACKWARD)
            self.rightMotor.setSpeed(abs(int(speed)))
            self.leftMotor.setSpeed(abs(int(speed + abs(angle))))  # right motor value up

        close_i2c_bus(i2c_bus)

    async def receive_command(self, websocket, path):
        if self.command_client_connected:
            # 기존 클라이언트가 연결되어 있음을 알리고 연결 종료
            await websocket.send(json.dumps({"error": "이미 명령 서버에 연결된 클라이언트가 있습니다."}))
            await websocket.close()
            print(f"추가 클라이언트가 명령 서버에 연결하려 했으나 거부되었습니다: {websocket.remote_address}")
            return

        self.command_client_connected = True
        print(f"명령 WebSocket 클라이언트가 연결되었습니다: {websocket.remote_address}")

        try:
            async for message in websocket:
                print(f"수신된 메시지: {message}")
                try:
                    # JSON 형식의 명령어를 파싱
                    data = json.loads(message)
                    command = data.get("command", "")
                    value = data.get("value", 0)

                    # 수신된 명령어에 따라 동작 처리
                    if command == "move":
                        angle = data.get("angle", 0)
                        speed = data.get("speed", 0)
                        self.move(angle, speed)
                    elif command == "stop":
                        self.stop()
                    else:
                        print("알 수 없는 명령어입니다.")
                except json.JSONDecodeError:
                    print("잘못된 JSON 형식의 메시지입니다.")
        except websockets.exceptions.ConnectionClosed:
            print("명령 WebSocket 클라이언트 연결이 종료되었습니다.")
        finally:
            self.command_client_connected = False

    async def frame_capture_loop(self):
        while True:
            ret, frame = self.cap.read()
            if not ret:
                print("프레임을 가져올 수 없습니다.")
                await asyncio.sleep(0.03)
                continue

            _, buffer = cv2.imencode('.jpg', frame)
            frame_data = base64.b64encode(buffer).decode('utf-8')

            async with self.frame_lock:
                self.current_frame = frame_data

            await asyncio.sleep(0.03)

    async def send_video(self, websocket, path):
        if self.video_client_connected:
            # 기존 클라이언트가 연결되어 있음을 알리고 연결 종료
            await websocket.send(json.dumps({"error": "이미 비디오 서버에 연결된 클라이언트가 있습니다."}))
            await websocket.close()
            print(f"추가 클라이언트가 비디오 서버에 연결하려 했으나 거부되었습니다: {websocket.remote_address}")
            return

        self.video_client_connected = True
        print(f"비디오 WebSocket 클라이언트가 연결되었습니다: {websocket.remote_address}")

        try:
            while True:
                async with self.frame_lock:
                    frame_data = self.current_frame

                if frame_data:
                    await websocket.send(frame_data)
                await asyncio.sleep(0.03)
        except websockets.exceptions.ConnectionClosed:
            print("비디오 WebSocket 클라이언트 연결이 종료되었습니다.")
        finally:
            self.video_client_connected = False

    async def start_servers(self):

        try:
            # 웹소켓 서버 시작
            print("웹소켓 서버가 시작됩니다.")
            video_server = await websockets.serve(self.send_video, '0.0.0.0', 8765)
            command_server = await websockets.serve(self.receive_command, '0.0.0.0', 8766)

            print("웹소켓 서버가 정상적으로 시작되었습니다.")

            # 프레임 캡처 루프 시작
            asyncio.create_task(self.frame_capture_loop())

            # 서버를 계속 실행시키기 위해 Future 대기
            await asyncio.Future()

        except Exception as e:
            print(f"서버 시작 중 오류 발생: {e}")

    def start_hp_con(self):
        asyncio.run(self.start_servers())

    def sig_callback(self, signal, frame):

        print('Signal Interrupted')
        print('프로그램이 종료 중입니다...')
        asyncio.get_event_loop().stop()  # asyncio 이벤트 루프 중단
        self.stop()

        if self.cap:
            self.cap.release()
            self.cap = None

        print('자원이 정리되었습니다. 종료합니다.')
        os._exit(0)  # 프로그램 완전 종료

    def led_left(self, on_off, back=None):
        try:
            pin = 12
            GPIO.setmode(GPIO.BOARD)
            GPIO.setup(pin, GPIO.OUT, initial=GPIO.LOW)  # set pin as an input pin

            if on_off == 0:
                GPIO.output(pin, 0)
            else:
                GPIO.output(pin, 1)
        finally:
            GPIO.cleanup()

    def led_right(self, on_off):
        try:
            pin = 11
            GPIO.setmode(GPIO.BOARD)
            GPIO.setup(pin, GPIO.OUT, initial=GPIO.LOW)  # set pin as an input pin
            if on_off == 0:
                GPIO.output(pin, 0)
            else:
                GPIO.output(pin, 1)
        finally:
            GPIO.cleanup()

    def beep(self):
        try:
            pin = 40
            GPIO.setmode(GPIO.BOARD)  # BOARD pin-numbering scheme
            GPIO.setup(pin, GPIO.OUT)  # button pin set as input
            GPIO.output(pin, 1)
        finally:
            GPIO.output(pin, 0)
            GPIO.cleanup()

    def delay(self, s):
        time.sleep(s)

    def net_wifi(self):
        cmd = "ifconfig wlan0"
        os.system(cmd)

    # hp_con과 video_stream_process는 필요 없으므로 제거
    # 만약 필요하다면, 아래 내용을 적절히 조정해야 합니다.

    def sig_callback(self, signal, frame):
        print('Signal Interrupted')
        print('프로그램이 종료 중입니다...')
        asyncio.get_event_loop().stop()
        self.stop()

        if self.cap:
            self.cap.release()
            self.cap = None

        print('자원이 정리되었습니다. 종료합니다.')
        os._exit(0)  # 프로그램 완전 종료


if __name__ == "__main__":
    try:
        robo = robot_control()
        print("로봇이 시작되었습니다.")
        robo.start_hp_con()
    except Exception as e:
        print(f"프로그램 실행 중 오류 발생: {e}")


