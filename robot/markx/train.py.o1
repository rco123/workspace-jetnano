#!/usr/bin/python3

import torch
import torch.nn.functional as F
import time
import os
import argparse
import re

from mark.mkmodel import lsModel
from lane.dset import ls_dataset

def train_model(epochs_no, batch_no):


    dir_path = "/home/jetson/share/mk"

    trans = transforms.Compose([

        transforms.Grayscale(num_output_channels=1),  # 그레이스케일로 변환

        transforms.Resize((64, 100)),    # nvidia file size
        transforms.ToTensor(),
        transforms.Normalize([0.5],[0.5])
        ])

    dataset = ImageFolder(dataset_loc, transform=trans )
    
    # 클래스와 라벨 매핑 출력 (디버깅용)
    print("클래스와 라벨 매핑:", dataset.class_to_idx)

    # DataLoader 설정
    data_loader = DataLoader(dataset, batch_size=batch_size, shuffle=True)


    device = torch.device('cuda')  # If you have a GPU, you can use 'cuda' instead of 'cpu'


    # 모델 초기화 및 장치로 이동
    model = mkModel().to(device)

    # 손실 함수 정의
    criterion = nn.CrossEntropyLoss()

    # 옵티마이저 정의 (예: Adam)
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    model.train()  # Set model to training mode


    # List to store the loss for each epoch
    epoch_losses = []
    epoch_accuracies=[]


    for epoch in range(epochs_no):

        running_loss = 0.0  # To accumulate loss over the epoch

        total = 0
        count = 0  # Track number of processed samples
        correct = 0

        elaps = time.time()  # Track the time taken per epoch

        _cnt = 0
        for img_name, images, angles in train_loader:
            
            # Move data to the appropriate device (CPU or GPU)
            images = images.to(device)
            angles = angles.to(device)

            # Zero gradients of parameters
            optimizer.zero_grad()

            # Forward pass: compute model output
            outputs = model(images)

            # Compute loss (Mean Squared Error for regression)
            loss = criterion(outputs, angles)

            # Backward pass: compute gradients
            loss.backward()

            # Update parameters
            optimizer.step()


            # 손실 누적
            running_loss += loss.item() * inputs.size(0)

            # 예측된 클래스
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()


        # 에포크 당 평균 손실 및 정확도 계산
        epoch_loss = running_loss / len(dataset)
        epoch_acc = correct / total * 100

        print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {epoch_loss:.4f}, Accuracy: {epoch_acc:.2f}%")


        # Compute average loss for the epoch
        avg_loss = running_loss / count
        epoch_losses.append(avg_loss)

        
        accuracy = correct / total if total > 0 else 0.0 # Avoid division by zero
        epoch_accuracies.append(accuracy)


        # Output loss and time taken for the epoch
        elaps = time.time() - elaps
        print(f'Epoch [{epoch + 1}/{epochs_no}], Loss: {avg_loss:.4f}, Time: {elaps:.2f} sec')

    return model, epoch_losses , epoch_accuracies


if __name__ == "__main__":
    # Argument parsing
    parser = argparse.ArgumentParser(description='arginput')

    parser.add_argument('--epochs', type=int, default=2)
    parser.add_argument('--batch', type=int, default=20)
    parser.add_argument('--out', type=str, default="models/mark.pt")

    args = parser.parse_args()

    batch = args.batch
    epochs = args.epochs
    out = args.out

    print('start training')

    # Train the model and get epoch losses
    model, epoch_losses, epoch_accuracies = train_model(epochs, batch)

    # Save the model
    torch.save(model.state_dict(), fname)

    # Plot the training loss over epochs using matplotlib
    import matplotlib.pyplot as plt

    plt.plot(epoch_losses, label='Training Loss')
    plt.title('Training Loss over Epochs')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()
    plt.savefig("/home/jetson/share/out/mark/loss.png")
    plt.close()

    plt.plot(epoch_accuracies, label='Training Accuracy')
    plt.title('Training Accuracy over Epochs')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy(%)')
    plt.legend()
    plt.savefig("/home/jetson/share/out/mark/acc.png")
    plt.close()

